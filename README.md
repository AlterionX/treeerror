One Ring to rule them all
```rs
// This doesn't entirely work yet
error_tree! {
  Mordor {
    Hobbit {
      @unit Peregrin,
      @unit Meriadoc,
      @unit Samwise,
      @unit Frodo,
      @unit Bilbo,
      @noconv Gollum,
    },
    Elf {
      @unit Galadriel,
      @unit Elrond,
      @unit Legolas,
      @unit Celebrimbor,
      @unit Arwen,
    },
    Wizard {
      @unit Saruman,
      @unit Gandalf,
      @unit Radagast,
    },
    Ents {
      @unit SorryIDoNotRememberYourName,
    },
    Man {
      @unit Theodin,
      @unit Denethor,
      @unit Eowyn,
      @unit Faramir,
      @unit Isildur,
      @unit Elendil,
      @unit Aragorn,
    },
    @unit Orc,
    @unit Shelob,
    @unit GenericPerson,
    @unit Gollum,
  }
}
```
One Ring to find them
```rs
// This and the rest do work though!
map_enum! {
  MiddleEarth > Mordor {
    Shire = Hobbit,
    Lothlorien = Elf,
    Rohan = Man,
    Gondor = Man,
    Wizard = Wizard,
    Gollum = Gollum,
    // I'm also still working on it, shush
  } @catchrest |_ignored| {
      Mordor::GenericPerson
  }
}
```
One Ring to bring them all
```rs
from_chain!(Mordor::Hobbit < Hobbit < (Peregrin, Meriadoc, Samwise, Frodo, Bilbo));
// And so on.
```
and in the darkness bind them.
```rs
// Muhahahaha!
from!(Mordor = Hobbit(Hobbit));
from!(Mordor = Hobbit(Peregrin));
from!(Mordor = Hobbit(Meriadoc));
from!(Mordor = Hobbit(Samwise));
from!(Mordor = Hobbit(Frodo));
from!(Mordor = Hobbit(Bilbo));
from!(Hobbit = Peregrin(Peregrin));
// And so on. These are all autogenerated by `error_tree!`
```

# In more seriousness

This crate is intended to provide some convenience enums for mapping enums from one type to
another. This is intended as an expansion of `thiserror` that has more compile time mapping
between sets of enums as well as shortcutting `From` implementations.

This is how to use wrapped errors.

```rs
#![feature(more_qualified_paths)]

use error_rules::{from_many, from};

#[derive(PartialEq, Debug)]
enum Root {
    A(A),
}
#[derive(PartialEq, Debug)]
enum A {
    Alpha(Alpha),
}
#[derive(PartialEq, Debug)]
enum Alpha {
    One(One),
}
#[derive(PartialEq, Debug)]
enum One {
    Child(Child),
}
#[derive(PartialEq, Debug)]
struct Child;

from_many!(Root: A, A, Alpha, One, Child);
from_many!(A: Alpha, Alpha, One, Child);
from_many!(Alpha: One, One, Child);
from!(One = Child(Child));

const MSG: &'static str = "hello from below";

fn root_error() -> Result<(), Root> {
  Err(Child)?;

  unreachable!("error should have returned earlier");
}

assert_eq!(
  Err(Root::A(A::Alpha(Alpha::One(One::Child(Child))))),
  root_error()
);
```

You'll notice that there are many `from_many` call here -- automatically generating this
tree is not yet complete and in progress.

We can also handle "flatter" error structures where, instead of nesting these enums by
wrapping them, we destructure the internal values instead.

There are several ways to use this as well, but here's the most basic use case.

```rs
#![feature(more_qualified_paths)]

use error_rules::map_enum;

#[derive(PartialEq, Eq, Debug)]
pub enum ParentError {
  Child(&'static str),
}

#[derive(PartialEq, Eq, Debug)]
pub enum ChildError {
  SomeError(&'static str),
}

map_enum!(ChildError > ParentError {
  SomeError > Child
});

const MSG: &'static str = "hello there";

fn parent_error() -> Result<(), ParentError> {
  Err(ChildError::SomeError(MSG))?;

  unreachable!("error should have returned earlier");
}

assert_eq!(
  Err(ParentError::Child(MSG)),
  parent_error(),
);
```

Some things that remain: combining all of this in a nice interface to autogenerate the
error chains, as well as packaging all of this stuff in a way to enable better error
messages during compilation. This potentially includes a proc macro rewrite to enable
better error messages and configurability.
